 TITLE 'CPU TEST'
*     ?DAC
*     VERSION 5.0
*     6/10/75
*     R CHRSITENSON
* 816 STATEMENTS
* DISK CONTROLLER BOARD 1 CHECK-OUT PROGRAM
*
*
* 09/20/78..........DBW MODIFIED TO WORK ON CPU4 OR CPU5
*
*
 EXTRN TST,GP,@AA,CH,CR,@PT
 EXTRN @HEX
*
*
************************************
*
* DISK CONTROLLER ADDRESSES
*
************************************
*
DISK EQU X'F140' DISK CONTROLLER BASE ADDRESS
DKCDNR EQU DISK * DISK NUMBER ADDRESS
DKCDAR EQU DISK+1 * DISK ADDRESS REGISTER
DKCWER EQU DISK+3 * WRITE ENABLE REGISTER
DKCSTS EQU DISK+4 * STATUS REGISTER
DKCCMD EQU DISK+8 * COMMAND REGISTER
DKCRST EQU DISK+11 * RESET COMMAND
DKCIEB EQU DISK+14 * ENABLE INTERRUPTS
DKCIDM EQU DISK+15 * DISARM INTERRUPTS
DKCDVS EQU 0 * DISK CONTROLLER DMA DEVICE NUMBER
ROM EQU X'EC00' LOADER ROM ADDRESS
*
*
******************************
*
*   DMA CONTROLLER ADDRESSES
*
******************************
*
*
DMAC EQU X'FFF0' DMA CONTROLLER BASE ADDRESS
DMCMAR EQU DMAC * MEMORY ADDRESS REGISTER
DMCBCR EQU DMAC+2 * COUNT REGISTER
DMCDVS EQU DMAC+4 * DEVICE SELECT REGISTER
DMCIL EQU DMAC+5 * INTERRUPT LEVEL REGISTER
DMCENB EQU DMAC+7 * DEVICE ENABLE
DMCIST EQU DMAC+12 * STIMULATE INTERRUPT
DMCIDB EQU DMAC+13 * DISABLE INTERRUPT
DMCIEB EQU DMAC+14 * ENABLE INTERRUPT
DMCIDM EQU DMAC+15 * DISARM INTERRUPT
*
*
***************************
*
* DISK CONSTANTS
*
***************************
*
*
CLYS EQU 406 NUMBER OF CYL PER DISK
SLGTH EQU 400 BYTES PER SECTOR
TLGTH EQU SLGTH*16 BYTES PER TRACK
CLGTH EQU TLGTH*2 BYTES PER CYL
TABL EQU 32*2 LENGTH OF BAD SECTOR TABLE
*
*
ILVL EQU 2 DISK INTERRUPT LEVEL
IS EQU ILVL*16+10 INTERRUPT LEVEL S-REG
IP EQU ILVL*16+14 INTERRUPT LEVEL P-REG
*
?DAC BEGIN 256 START-UP POINT
 LDAB= -1
 STAB/ DISK+11 CLEAR DISK CONTROLLER
 STAB/ DMAC+6 CLEAR DMA CONTROLLER
 LDA= X'5555'
 XAB
 STA/ DMCMAR PUT 5555 IN CPU4 DMA MAR
 CLA
 LDA/ DMCMAR FETCH IT BACK
 SAB WAS IT THERE
 BNZ DD10 NO MUST BE A CPU5
 LDA= STACK
 STA/ X'1A' SET UP RESTARTS
 STA/ X'2A'
 STA/ @AA SET UP CONSOLE ABORT
 STAB/ CH INSURE NEW LINE
 LDAB= '='
 STAB/ @PT PROMPT CHARACTER
 LDA= STACK
 XAS SET UP STACK
 CLAB
 JMP/ DD20
DD10 EQU *
 LDA= ?DAC
 XAS SET UP STACK
 STA/ @AA SET UP CONSOLE ABORT
 LDA/ STACK
 STA/ IS SET INTERRUPT LEVEL S-STACK
 STAB/ DKCIDM CLEAR INTERRUPT FLAGS
 STAB/ DKCIEB DISK INTERRUPT ENABLE
 LDAB= 1
DD20 EQU *
 STAB/ CPU5SW
 EI ENABLE INTERRUPTS
 JMP/ DMASU DO DMA SET-UP
 LDB= 0
CURTK EQU *-2
*
*******************
*
* DMA SET-UP
*
*******************
*
DMASU EQU *
 LDBB= 0
CPU5SW EQU *-1
 BZ DS10
 DMA SAD,A BUFFER ADDR
 LDA= .NOT.TLGTH
 DMA SCT,A SET COUNT
 DMA SDV,DKCDVS SELECT DEVICE
 DMA EAB ENABLE DMA
 JMP DS20
DS10 EQU *
 STA/ DMCMAR BUFFER ADDRESS
 LDA= .NOT.TLGTH
 STA/ DMCBCR LENGTH
 LDAB= DKCDVS
 STAB/ DMCDVS SELECT DEVICE
 STAB/ DMCENB ENABLE DEVICE
 LDAB= ILVL
 STAB/ DMCIL SET INTERRUPT LEVEL
DS20 EQU *
 STAB/ DKCIDM CLEAR INTERRUPTS
 STAB/ DKCIEB ENABLE INTERRUPTS
 LDAB= 0
DNUM EQU *-1
 STAB/ DKCDNR SELECT SELECT DISK
 STAB/ DKCIEB ENABLE DISK INTERRUPT
 LDA/ CURTK TRACK ADDR
 STA/ DKCDAR SET UP ADDRESS REGISTER
*
*
************************
*
*  SIGN-ON MESSAGE
*
************************
*
*
 LDAB= *-*
SOSWT EQU *-1
 BZ SKIP SIGN ON NOT PRINTED
 JMP/ SKIPSO SIGN ON ALREADY PRINTED
SKIP EQU *
 INAB
 STAB/ SOSWT SET SWITCH
 JSR/ TST
 DW MSGSO "DISK CONTROLLER BOARD 1 CHECKOUT 5.0"
SKIPSO EQU *
 JSR/ TST
 DW MSGQ "ENTER TEST CODE"
 LDAB= X'8D' CR
 STAB/ CH INHIBIT NEW LINE
 JSR/ GP GET OPERATOR RESPONSE
 DW RPLY
 LDA RPLY
 BNZ RTNFD REPLY NOT NULL
* NULL REPLY: PERFORM NEXT TEST
NXTST EQU *
 LDB= ADRTAB GET TABLE POINTER
TABPNT EQU *-2
 LDA- B+ GET ROUTINE ADDRESS
 INA ENTRY POINT ADDRESS
 BNZ NTABND NOT END OF TABLE
* OUT OF TESTS, START OVER
 LDA @ATAD FIRST TEST
 STA TABPNT RESET POINTER
 JMP NXTST
NTABND EQU * ENTER NEXT ROUTINE
 STB TABPNT UPDATE POINTER
 JMP- A ENTER TEST
*
* LOOK UP DESIRED ROUITNE
*
RTNFD EQU *
 LDA= ADRTAB
@ATAD EQU *-2
 XAY
 LDAB RPLY+2 OPERATOR RESPONSE
 LDBB= 'A'
 SABB
 BM INVAL INVALID RESPONSE
 LDBB= X'DF'
 ANDB B,A SET TO UPPER CASE
LOOP EQU * SCAN THROUGH ROUTINES
 LDX- Y+ ADDR OF ROUTINE
 LDBB- X+ CODE CHARACTER
 XFR X,X
 BZ INVAL INVALID CODE
 SABB
 BNZ LOOP NOT FOUND
 XFR Y,A TABLE POINTER
 STA TABPNT RESET POINTER
 JMP- X ENTER REQUESTED RTN
INVAL EQU *
 JMP/ ?DAC TRY AGAIN
*
* ADDRESS TABLE
*
ADRTAB EQU *
 DW ?DACR
 DW ?DACW
 DW ?DACD
 DW ?DACA
 DW ?DACC
 DW ?DACE
 DW ?DACS
 DW -1 TERMINATOR
*
* MESSAGES
*
MSGSO DW MSGQ-*-2
 DC 'DISK CONTROLLER BOARD 1 CHECKOUT 1.1'
MSGQ DW RPLY-*-2
 DC 'ENTER TEST CODE'
RPLY DW 1
 DB 0
MSG19 DW M19-*-2
 DC '** CPU4 **'
M19 EQU *
*
MSG20 DW M20-*-2
 DC '** CPU5 **'
M20 EQU *
*
* STACK AREA
*
STACK EQU *+16
 ORG STACK
*
***********************************
*                                 *
*        SUBROUTINE ?DACR         *
*                                 *
***********************************
*
* READ TEST
*
?DACR EQU *
 DC 'R' CODE CHARACTER
 JSR/ TST
 DW RMSG "READ TEST 1.1"
 JSR/ CR
 DI
RLOOP EQU *
 LDAB/ DISK READ BYTE
 JMP RLOOP
*
* SIGN-ON MESSAGE
*
RMSG DW RMEND-*-2
 DC 'READ TEST 1.1'
RMEND EQU *
*
***********************************
*                                 *
*        SUBROUTINE ?DACW         *
*                                 *
***********************************
*
* WRITE TEST
*
?DACW EQU *
 DC 'W' CODE CHARACTER
 JSR/ TST
 DW WMSG "WRITE TEST 1.1"
 JSR/ CR
 DI
WLOOP EQU *
 STAB/ DISK WRITE BYTE
 JMP WLOOP
*
* SIGN-ON MESSAGE
*
WMSG DW WMEND-*-2
 DC 'WRITE TEST 1.1'
WMEND EQU *
*
***********************************
*                                 *
*        SUBROUTINE ?DACD         *
*                                 *
***********************************
*
* DATA VALUES TEST
*
?DACD EQU *
 DC 'D' CODE CHARACTER
 JSR/ TST
 DW DMSG "DATA VALUES TEST 1.1"
 JSR/ CR
 DI
*
* VALUE TEST
*
 LDX= DTSTB TABLE POINTER
DLOOP EQU *
 LDA- X+ ADDR OF BYTE
 BZ XTKTST END OF TABLE, GO TO CROSSTALK TEST
 XAY
 LDAB- X+ GET MASK
 XAZB SAVE IT
 CLAB INITIALIZE TEST VALUE
DTLP EQU * TEST A VALUE
 STAB- Y STORE
 LDBB- Y FETCH
 STBB- S- SAVE VALUE FETCHED
 OREB A,B COMPARE VALUES
 ANDB Z,B STRIP TO ACTIVE BITS
 BZ DVOK FETCHED = STORED
* VALUE ERROR, PREPARE AND PRINT ERROR MESSAGE
 LDBB- S+ FETCHED VALUE
 STAB- S- SAVE TEST VALUE
 JSR/ @HEX CONVERT STORED VALUE TO HEX
 STA/ SVAL PUT IN MSG
 XFRB BL,A FETCHED VALUE
 JSR/ @HEX
 STA/ FVAL PUT IN MSG
 XFRB YL,A LO BYTE OF ADDR
 JSR/ @HEX
 STA/ VALAD PUT IN MSG
 JSR/ TST
 DW VALERM "VALUE ERROR: F14X XX XX'
 LDAB- S RESTORE TEST VALUE
DVOK EQU * ADVANCE TO NEXT VALUE
 INR S STEP OVER SAVED VALUE
 INAB NEXT TEST VALUE
 BNZ DTLP TEST NEXT VALUE
 JMP DLOOP TEST NEXT BYTE
*
* CROSSTALK TEST
*
XTKTST EQU *
 LDA= DTSTB
 XAZ TABLE POINTER FOR BYTE TESTED
XTL1 EQU * TEST A BYTE
 JSR CLRBTS 0'S TO REGISTERS
 CLAB 0'S TO TEST BYTE
 JSR B0TST TEST FOR 0'S
 JSR CLRBTS 0'S TO REGISTERS
 CLAB
 IVAB 1'S TO TEST BYTE
 JSR B0TST TEST FOR 0'S
 JSR SETBTS 1'S TO REGISTERS
 CLAB 0'S TO TEST BYTE
 JSR B1TST TEST FOR 1'S
 JSR SETBTS 1'S TO REGISTERS
 CLAB
 IVAB 1'S TO TEST BYTE
 JSR B1TST TEST FOR 1'S
 INR Z,3 NEXT TABLE ENTRY
 LDA- Z
 BNZ XTL1 CONTINUE
* END OF CROSSTALK TEST, EXIT
 JSR/ TST
 DW DTBYE "DATA TEST COMPLETED"
 JMP/ ?DAC
* PRESET REGISTERS FOR CROSSTALK TEST
CLRBTS EQU * 0'S
 CLRB B
 JMP *+4
SETBTS EQU * 1'S
 LDBB= X'FF'
 STBB- S- SAVE SET VALUE
 LDA= DTSTB
 XAY TABLE POINTER
 LDAB- S+ GET SET VALUE
CLBL EQU * SET A BYTE
 LDB- Y+ ADDR OF BYTE
 BZ CLBXIT END OF TABLE, EXIT
 STAB- B SET BYTE
 INR Y STEP OVER MASK
 JMP CLBL REPEAT
CLBXIT EQU * EXIT
 RSR
* STORE TEST VALUE IN TEST BYTE AND CHECK OTHER BYTES FOR CHANGE
B0TST EQU * TEST FOR 0'S
 CLRB B
 JMP *+4
B1TST EQU * TEST FOR 1'S
 LDBB= X'FF'
 STBB TVAL SAVE EXPECTED VALUE
 STAB- *Z SET TEST BYTE
 LDA= DTSTB
 XAY TABLE POINTER FOR BYTE CHECKED
BTSTL EQU * CHECK OTHER BYTES
 XFR Z,A TEST POINTER
 SUB Y,A SUBTRACT CHECK POINTER
 BZ BTX DON'T CHECK TEST BYTE
 LDB- Y+ ADDR OF BYTE CHECKED
 BZ CLBXIT END OF TABLE, RETURN
 LDAB- B GET VALUE IN BYTE CHECKED
 STAB- S- SAVE VALUE
 LDBB= *-*
TVAL EQU *-1 EXPECTED VALUE
 OREB B,A COMPARE
 LDBB- Y GET MASK
 NABB STRIP TO ACTIVE BITS
 BZ NXT NOT ERROR
* CROSSTALK ERROR, PREPARE AND PRINT ERROR MESSAGE
 LDA- Z ADDR OF TEST BYTE
 JSR/ @HEX
 STA TBADR PUT IN MSG
 LDAB- Y,-1 LO BYTE OF CHECK ADDR
 JSR/ @HEX
 STA CBADR PUT IN MSG
 LDAB TVAL GET EXPECTED VALUE
 LDBB- Y GET MASK
 ANDB B,A STRIP TO ACTIVE BITS
 JSR/ @HEX
 STA CBEXP PUT IN MSG
 LDAB- S GET FETCHED VALUE
 LDBB- Y GET MASK
 ANDB B,A STRIP TO ACTIVE BITS
 JSR/ @HEX
 STA CBVAL PUT IN MSG
 JSR/ TST
 DW XTMSG "CROSSTALK ERROR: F14X F14X XX XX"
NXT EQU * ADVANCE TO NEXT BYTE CHECKED
 INR S STEP OVER VALUE SAVED
 JMP *+6
BTX EQU *
 INR Y,2 STEP OVER ADDRESS
 INR Y STEP OVER MASK
 JMP BTSTL CHECK NEXT BYTE
*
* TABLE OF ADDRESS AND ACTIVE-BIT MASKS FOR SETTABLE REGISTERS
*
DTSTB EQU *
 DW DISK
 DB X'0F'
 DW DISK+1
 DB X'FF'
 DW DISK+2
 DB X'FF'
 DW DISK+3
 DB X'FF'
 DW 0
*
* MESSAGES
*
DMSG DW VALERM-*-2
 DC 'DATA VALUES TEST 1.1'
VALERM DW XTMSG-*-2
 DC 'VALUE ERROR: F1'
VALAD DC '  ' LO BYTE OF ADDRESS
 DC ' '
SVAL DC '  ' STORED VALUE
 DC ' '
FVAL DC '  ' FETCHED VALUE
XTMSG DW DTBYE-*-2
 DC 'CROSSTALK ERROR: F1'
TBADR DC '  ' LO BYTE OF TEST ADDR
 DC ' F1'
CBADR DC '  ' LO BYTE OF CHECK ADDR
 DC ' '
CBEXP DC '  ' EXPECTED VALUE
 DC ' '
CBVAL DC '  ' VALUE FOUND
DTBYE DW DMEND-*-2
 DC 'DATA TEST COMPLETED'
DMEND EQU *
*
***********************************
*                                 *
*        SUBROUTINE ?DACA         *
*                                 *
***********************************
*
* ADDRESS TEST
*
?DACA EQU *
 DC 'A' CODE CHARACTER
 JSR/ TST
 DW AMSG "ADDRESS TEST 1.1"
 JSR/ CR
 DI
 LDA= TSTAB
 XAY TABLE POINTER
ALOOP EQU *
 LDX- Y+ GET TEST ADDRESS
 BZ ?DACAX END OF TABLE
 LDAB- X FETCH FROM TEST ADDRESS
 IVAB
 STAB/ DISK+1 STORE IN DISK CONTROLLER
 IVAB
 STAB- X STORE VALUE FETCHED AT TEST ADDRESS
 IVAB
 LDBB/ DISK+1 FETCH VALUE FROM CONTROLLER
 SABB COMPARE
 BZ ALOOP VALUE UNCHANGED
* ADDRESS ERROR, SET UP AND PRINT ERROR MESSAGE
 XFRB XU,A
 JSR/ @HEX CONVERT HI BYTE OF TEST ADDR TO HEX
 STA EAD1 PUT IN MESSAGE
 XFRB XL,A
 JSR/ @HEX CONVERT LO BYTE OF TEST ADDR TO HEX
 STA EAD2 PUT IN MESSAGE
 JSR/ TST
 DW ADERM "ADDRESS ERROR: XXXX"
 JMP ALOOP
?DACAX EQU * EXIT
 JSR/ TST
 DW ATBYE "ADDRESS TEST COMPLETED"
 JMP/ ?DAC
*
* TEST ADDRESS TABLE
*
TSTAB EQU *
 DW DISK.XOR.X'8000'
 DW DISK.XOR.X'4000'
 DW DISK.XOR.X'2000'
 DW DISK.XOR.X'1000'
 DW DISK.XOR.X'0800'
 DW DISK.XOR.X'0400'
 DW DISK.XOR.X'0200'
 DW DISK.XOR.X'0100'
 DW DISK.XOR.X'0080'
 DW DISK.XOR.X'0040'
 DW DISK.XOR.X'0020'
 DW DISK.XOR.X'0010'
 DW DISK+8
 DW ROM
 DW 0
*
* MESSAGES
*
AMSG DW ADERM-*-2
 DC 'ADDRESS TEST 1.1'
ADERM DW ATBYE-*-2
 DC 'ADDRESS ERROR: '
EAD1 DC '  ' HI BYTE OF ERROR ADDRESS
EAD2 DC '  ' LO BYTE OF ERROR ADDRESS
ATBYE DW AMEND-*-2
 DC 'ADDRESS TEST COMPLETED'
AMEND EQU *
*
***********************************
*                                 *
*        SUBROUTINE ?DACC         *
*                                 *
***********************************
*
* CLEAR TEST
*
?DACC EQU *
 DC 'C' CODE CHARACTER
 JSR/ TST
 DW CMSG "CLEAR TEST 1.1"
 JSR/ CR
 DI
 LDAB= -1
 STAB/ DISK SET UP REGISTERS
 STAB/ DISK+1
 STAB/ DISK+2
 STAB/ DISK+3
 LDAB= 5
 STAB/ DISK+11 RESET COMMAND
 LDAB/ DISK FETCH DISK SELECT REGISTER
 LDBB= X'0F'
 NABB STRIP
 LDAB= 5
 SABB
 BNZ DCERR DIDN'T SET
 LDB= DISK+1
 LDAB- B+ FETCH HI BYTE OF DISK ADDRESS
 BNZ CERR NOT CLEARED
 LDAB- B+ FETCH LO BYTE OF DISK ADDRESS
 BNZ CERR NOT CLEARED
 LDAB- B+ FETCH WE REGISTER
 BNZ CERR NOT CLEARED
 JSR/ TST
 DW CTBYE "CLEAR TEST COMPLETED"
CTXIT EQU *
 JMP/ ?DAC
*
DCERR EQU * DISK SELECT REGSITER DIDN'T SET
 LDAB/ DISK VALUE IN REGISTER
 LDB= DISK+1
CERR EQU * REGISTER DIDN'T CLEAR
 JSR/ @HEX GET HEX OF VALUE FETCHED
 STA CEVAL
 DCR B ADDRESS OF ERROR
 XFRB BU,AL
 JSR/ @HEX
 STA CEADHI HEX OF HI BYTE OF ADDR
 XFRB BL,AL
 JSR/ @HEX
 STA CEADLO HEX OF LO BYTE OF ADDR
 JSR/ TST
 DW CEMSG "CLEAR ERROR: XXXX XX"
 JMP CTXIT
*
*  MESSAGES
*
CMSG DW CEMSG-*-2
 DC 'CLEAR TEST 1.1'
*
CEMSG DW CTBYE-*-2
 DC 'CLEAR ERROR: '
CEADHI DC 'XX'
CEADLO DC 'XX '
CEVAL DC 'XX'
*
CTBYE DW CMEND-*-2
 DC 'CLEAR TEST COMPLETED'
CMEND EQU *
*
***********************************
*                                 *
*        SUBROUTINE ?DACE         *
*                                 *
***********************************
*
* WRITE ENABLE TEST
*
?DACE EQU *
 DC 'E' CODE CHARACTER
 JSR/ TST
 DW EMSG "WRITE ENABLE TEST 1.1"
 JSR/ CR
 DI
 CLAB
 STAB/ DISK+11 CLEAR DISK SELECT AND WRITE ENABLE REGISTERS
ELOOP EQU *
 LDAB/ DISK GET DISK NUMBER
 LDBB= X'07'
 NABB STRIP
 LDAB/ DISK+3 GET WE REGISTER
 SRAB
 DCRB B
 BP *-3 SHIFT WE BIT FOR SELECTED DISK INTO LINK
 RRRB B BL.LT.0 IF ENABLED
 LDAB/ DISK+5 GET LO BYTE OF STATUS
 RLRB A WE BIT TO BIT 7
 OREB A,B
 BM WERR ERROR
ENEXT EQU * SET UP NEXT TEST
 LDAB/ DISK+3 GET WE REGISTER
 INAB
 STAB/ DISK+3
 BNZ ELOOP NO CARRY
 LDAB/ DISK GET DISK NUMBER
 LDBB= X'F0'
 ORIB B,A OR IN NONEXISTENT BITS
 INAB
 STAB/ DISK
 BNZ ELOOP NOT DONE
 JSR/ TST
 DW ETBYE "END WRITE ENABLE TEST"
 JMP/ ?DAC
*
WERR EQU * WRITE ENABLE ERROR
 LDAB/ DISK GET DISK NUMBER
 LDBB= X'0F'
 ANDB B,A STRIP
 JSR/ @HEX
 STAB WEDN HEX OF DISK NUMBER
 LDAB/ DISK+3 GET WE REGISTER
 JSR/ @HEX
 STA WEREG HEX OF WE REGISTER
 JSR/ TST
 DW WEMSG "ERROR: X XX"
 JMP ENEXT
*
* SIGN-ON MESSAGE
*
EMSG DW WEMSG-*-2
 DC 'WRITE ENABLE TEST 1.1'
*
WEMSG DW ETBYE-*-2
 DC 'ERROR: '
WEDN DC 'X '
WEREG DC 'XX'
*
ETBYE DW EMEND-*-2
 DC 'END WRITE ENABLE TEST'
EMEND EQU *
*
***********************************
*                                 *
*        SUBROUTINE ?DACS         *
*                                 *
***********************************
*
* SECTOR ADDRESS TEST
*
?DACS EQU *
 DC 'S' CODE CHARACTER
 JSR/ TST
 DW SMSG "SECTOR ADDRESS TEST 1.1"
 JSR/ CR
 DI
 LDX= SALIST SECTOR ADDRESS LIST
SLOOP EQU * TEST LOOP
 LDA- X GET SA
 INA
 BZ STXIT DONE
 DCA
 STA/ DISK+1 DISK ADDRESS
 LDA= DBUF
 STA/ DMAC SET UP MAR
 LDA= -2
 STA/ DMAC+2 SET UP COUNT
 CLAB
 STAB/ DISK DISK 0
 STAB/ DMAC+4 DEVICE 0
 STAB/ DMAC+7 ENABLE
 JSR DSTST TEST STATUS
 LDAB= 2
 STAB/ DISK+8 SEEK COMMAND
 JSR DSTST WAIT FOR SEEK
 LDAB= 0
 STAB/ DISK+8 READ SECTOR
DWAIT EQU * WAIT FOR READ
 JSR DSTST
 LDB= X'0100'
 NAB
 BNZ DWAIT BUSY
 LDA- X+ DISK ADDRESS
 RRR A SHIFT RIGHT
 XAB
 RRR B SHIFT RIGHT
 ORI A,B
 LDA/ DISK+4 GET STATUS
 ORE A,B BIT 13 = BIT 14 OR BIT 15 OF ADDRESS XOR ADDRESS ERROR BIT
 LDA= X'2000'
 NAB
 BZ SLOOP
* ERROR, DISPLAY MESSAGE
 LDAB/ DISK+1
 JSR/ @HEX
 STA/ SADHI HEX OF HI BYTE OF ADDR
 LDAB/ DISK+2
 JSR/ @HEX
 STA/ SADLO HEX OF LO BYTE OF ADDR
 JSR/ TST
 DW SAMSG "ADDR REG ERROR: XXXX"
STXIT EQU *
 JSR/ TST
 DW STBYE "END SECTOR ADDRESS TEST"
 JMP/ ?DAC
*
DSTST EQU * TEST DISK STATUS
 LDA/ DISK+4 GET STATUS
 LDB= X'0E00'
 NAB
 BNZ DSTER STATUS ERROR
 LDB= X'0010'
 NAB
 BZ DSTER NOT READY
 LDB= X'0020'
 NAB
 BZ DSTST NOT ON CYLINDER, WAIT
 RSR
DSTER EQU * STATUS ERROR
 JSR/ @HEX
 STA DSTLO HEX OF LO BYTE OF DISK STATUS
 LDAB/ DISK+4
 JSR/ @HEX
 STA DSTHI HEX OF HI BYTE OF DISK STATUS
 JSR/ TST
 DW DSTMSG "STATUS ERROR: XXXX"
 LDX- S+ UNWIND JSR
 JMP STXIT
*
SALIST EQU * LIST OF SECTOR ADDRESSES
 DW X'0000'
 DW X'0001'
 DW X'0002'
 DW X'0004'
 DW X'0008'
 DW X'0010'
 DW X'0020'
 DW X'0040'
 DW X'0080'
 DW X'0100'
 DW X'0200'
 DW X'0400'
 DW X'0800'
 DW X'1000'
 DW X'2000'
 DW X'4000'
 DW X'8000'
 DW -1
*
DBUF DB *-* DISK BUFFER
*
* MESSAGES
*
SMSG DW SAMSG-*-2
 DC 'SECTOR ADDRESS TEST 1.1'
*
SAMSG DW DSTMSG-*-2
 DC 'ADDR REG ERROR: '
SADHI DC 'XX'
SADLO DC 'XX'
*
DSTMSG DW STBYE-*-2
 DC 'STATUS ERROR: '
DSTHI DC 'XX'
DSTLO DC 'XX'
*
STBYE DW SMEND-*-2
 DC 'END SECTOR ADDRESS TEST'
SMEND EQU *
*
*
*
 END ?DAC
